# 4. Functions

A **function** is a reusable sequence of statements designed to do a particular job.

Functions that you write yourself are called **user-defined functions**. 

A **function call** is an expression that tells the CPU to interrupt the current function and execute another function.

The compiler compiles the contents of code files sequentially. Hence functions must be defined before their use on a latter line. (Unless: A **forward declaration** allows us to tell the compiler about the existence of an identifier *before* actually defining the identifier.)

- Just like variables have names, so do user-defined functions. The *identifier* is the name of your user-defined function.

- The parentheses after the identifier tell the compiler that we’re defining a function.

  Example of fucntion use:

```
#include <iostream> // for std::cout

// Definition of user-defined function doPrint()
void doPrint() // doPrint() is the called function in this example
{
    std::cout << "In doPrint()\n";
}

// Definition of function main()
int main()
{
    std::cout << "Starting main()\n";
    doPrint(); // Interrupt main() by making a function call to doPrint().  main() is the caller.
    std::cout << "Ending main()\n"; // this statement is executed after doPrint() ends

    return 0;
}
```

Unlike some other programming languages, in C++, functions cannot be defined inside other functions.

## Return values

When you write a user-defined function, you get to determine whether your function will return a value back to the caller or not. To return a value back to the caller, two things are needed.

1. Your function has to indicate what type of value will be returned. This is done by setting the function’s **return type**, which is the type that is defined before the function’s name.

2. A return statement is needed, return the **return value**.

   **Tip:** When a called function returns a value, the caller may decide to use that value in an expression or statement (e.g. by assigning it to a variable, or sending it to `std::cout`) or ignore it (by doing nothing else).

   Return types

- void
- value returning function

**Best practice:** Make sure your functions with non-void return types return a value in all cases. Failure to return a value from a value-returning function will cause undefined behavior.

**Best practice:** Follow the DRY best practice: “don’t repeat yourself”. If you need to do something more than once, consider how to modify your code to remove as much redundancy as possible. Variables can be used to store the results of calculations that need to be used more than once (so we don’t have to repeat the calculation).

### Void functions:

A function that does not return a value is called a **non-value returning function** (or a **void function**).

**Void functions can’t be used in expression that require a value**

A return statement that is not the last statement in a function is called an **early return**. Such a statement will cause the function to return to the caller when the return statement is executed (before the function would otherwise return to the caller, hence, “early”). It is okay to use return in void functions, but only to go back, not return a value!

## Function arguments

When a function is called, all of the parameters of the function are created as variables, and the value of each of the arguments is *copied* into the matching parameter. This process is called **pass by value**. 

```cpp
// This function has two integer parameters, one named x, and one named y
// The values of x and y are passed in by the caller
void printValues(int x, int y)
{
    std::cout << x << '\n';
    std::cout << y << '\n';
}

int main()
{
    printValues(6, 7); // This function call has two arguments, 6 and 7

    return 0;
}
```

Note that the number of arguments must generally match the number of function parameters, or the compiler will throw an error.

Function arguments can be another functions return value (direct).

Function parameters and return values are the key mechanisms by which functions can be written in a reusable way, as it allows us to write functions that can perform tasks and return retrieved or calculated results back to the caller without knowing what the specific inputs or outputs are ahead of time.

### Default Arguments

A **default argument** is a default value provided for a function parameter. For example:

```cpp
void print(int x, int y=10) // 10 is the default argument
{
    std::cout << "x: " << x << '\n';
    std::cout << "y: " << y << '\n';
}
```

When making a function call, the caller can optionally provide an argument for any function parameter that has a default argument. If the caller provides an argument, the value of the argument in the function call is used. If the caller does not provide an argument, the value of the default argument is used.

```cpp
#include <iostream>

void print(int x, int y=4) // 4 is the default argument
{
    std::cout << "x: " << x << '\n';
    std::cout << "y: " << y << '\n';
}

int main()
{
    print(1, 2); // y will use user-supplied argument 2
    print(3); // y will use default argument 4

}
```

**Rule**: Default arguments can only be provided for the rightmost parameters.

Once declared, a default argument can not be redeclared (in the same file). That means for a function with a forward declaration and a function definition, the default argument can be declared in either the forward declaration or the function definition, but not both.

```cpp
#include <iostream>

void print(int x, int y=4); // forward declaration

void print(int x, int y=4) // error: redefinition of default argument
{
    std::cout << "x: " << x << '\n';
    std::cout << "y: " << y << '\n';
}
```

**Best practice**: If the function has a forward declaration (especially one in a header file), put the default argument there. Otherwise, put the default argument in the function definition.

## Local scope:

Variables defined inside a function are local variables. 

Local variables are destroyed in the opposite order of creation at the end of the set of curly braces in which it is defined (or for a function parameter, at the end of the function). 

Objects must be created and initialized no later than the point of definition, and destroyed no earlier than the end of the set of the curly braces in which they are defined (or, for function parameters, at the end of the function).

An identifier’s **scope** determines where the identifier can be accessed within the source code. When an identifier can be accessed, we say it is **in scope**. When an identifier can not be accessed, we say it is **out of scope**.

**Key Insight:** Names used for function parameters or variables declared in a function body are only visible within the function that declares them. This means local variables within a function can be named without regard for the names of variables in other functions. This helps keep functions independent. 

**Best practice:** Define your local variables as close to their first use as reasonable.

### Static local variables:

Local variables have `automatic duration` by default, which means they are created at the point of definition, and destroyed when the block is exited.

Using the `static` keyword on a local variable changes its duration from `automatic duration` to `static duration`. 

This means the variable is now created at the start of the program, and destroyed at the end of the program (just like a global variable). 

Just like we use “g_” to prefix global variables, it’s common to use “s_” to prefix static (static duration) local variables.

One of the most common uses for static duration local variables is for unique ID generators.

They cannot be tampered with by functions outside of their scope, making them safer than global variables. 

**Best practice**: Initialize your static local variables. Static local variables are only initialized the first time the code is executed, not on subsequent calls.

**Best practice**: Avoid `static` local variables unless the variable never needs to be reset.

## Reasons to use functions:

- Organization -- As programs grow in complexity, having all the code live inside the main() function becomes increasingly complicated. A function is almost like a mini-program that we can write separately from the main program, without having to think about the rest of the program while we write it. This allows us to reduce a complicated program into smaller, more manageable chunks, which reduces the overall complexity of our program.
- Reusability -- Once a function is written, it can be called multiple times from within the program. This avoids duplicated code (“Don’t Repeat Yourself”) and minimizes the probability of copy/paste errors. Functions can also be shared with other programs, reducing the amount of code that has to be written from scratch (and retested) each time.
- Testing -- Because functions reduce code redundancy, there’s less code to test in the first place. Also because functions are self-contained, once we’ve tested a function to ensure it works, we don’t need to test it again unless we change it. This reduces the amount of code we have to test at one time, making it much easier to find bugs (or avoid them in the first place).
- Extensibility -- When we need to extend our program to handle a case it didn’t handle before, functions allow us to make the change in one place and have that change take effect every time the function is called.
- Abstraction -- In order to use a function, you only need to know its name, inputs, outputs, and where it lives. You don’t need to know how it works, or what other code it’s dependent upon to use it. This lowers the amount of knowledge required to use other people’s code (including everything in the standard library).



### Forward Declaration:

```cpp
#include <iostream>

int add(int x, int y); // forward declaration of add() (using a function declaration)

int main()
{
    std::cout << "The sum of 3 and 4 is: " << add(3, 4) << '\n'; // this works because we forward declared add() above
    return 0;
}

int add(int x, int y) // even though the body of add() isn't defined until here
{
    return x + y;
}
```

### Definition and declaration:

- A **definition** actually implements (for functions or types) or instantiates (for variables) the identifier. 

  In C++, all definitions also serve as declarations. 

A definition is needed to satisfy the *linker*. If you use an identifier without providing a definition, the linker will error.

The **one definition rule** (or ODR for short) is a well-known rule in C++. The ODR has three parts:

1. Within a given *file*, a function, variable, type, or template can only have one definition.
2. Within a given *program*, a variable or normal function can only have one definition. This distinction is made because programs can have more than one file (we’ll cover this in the next lesson).
3. Types, templates, inline functions, and inline variables are allowed to have identical definitions in different files. We haven’t covered what most of these things are yet, so don’t worry about this for now -- we’ll bring it back up when it’s relevant.

- A **declaration** is a statement that tells the *compiler* about the existence of an identifier and its type information. (satisfy *compiler*)

### Multiple files:

**Best practice:** When you add new code files to your project, give them a .cpp extension.

The compiler compiles each file individually. It does not know about the contents of other code files, or remember anything it has seen from previously compiled code files.

This limited visibility and short memory is intentional, so that files may have functions or variables that have the same names without conflicting with each other.

Hence, we need to place a forward declaration before the main function. 

Using this method, we can give files access to functions that live in another file.

**Reminder:** Whenever you create a new code (.cpp) file, you will need to add it to your project so that it gets compiled.

##### Header Files:

**Key insight:** Header files allow us to put declarations in one location and then import them wherever we need them. This can save a lot of typing in multi-file programs. 

**Best practice:** Header files should generally not contain function and variable definitions, so as not to violate the one definition rule. An exception is made for symbolic constants.

![image-20221003110345197](C:\Users\Johan\AppData\Roaming\Typora\typora-user-images\image-20221003110345197.png)

**Best practice:** Use a .h suffix when naming your header files. If a header file is paired with a code file (e.g. add.h with add.cpp), they should both have the same base name (add). 

add.h:

```cpp
// 1) We really should have a header guard here, but will omit it for simplicity (we'll cover header guards in the next lesson)

// 2) This is the content of the .h file, which is where the declarations go
int add(int x, int y); // function prototype for add.h -- don't forget the semicolon!
```

add.cpp:

```cpp
#include "add.h" // Insert contents of add.h at this point.  Note use of double quotes here.

int add(int x, int y)
{
    return x + y;
}
```

main.cpp:

```cpp
#include "add.h" // Insert contents of add.h at this point.  Note use of double quotes here.
#include <iostream>

int main()
{
    std::cout << "The sum of 3 and 4 is " << add(3, 4) << '\n';
    return 0;
}
```

**Best practice:** Source files should #include their paired header file (if one exists).

**Rule:** Use double quotes to include header files that you’ve written or are expected to be found in the current directory. Use angled brackets to include headers that come with your compiler, OS, or third-party libraries you’ve installed elsewhere on your system.

**Best practice:** When including a header file from the standard library, use the version without the .h extension if it exists. User-defined headers should still use a .h extension.

**Best practice:** Each file should explicitly #include all of the header files it needs to compile. Do not rely on headers included transitively from other headers.

**Best practice:** To maximize the chance that missing includes will be flagged by compiler, order your #includes as follows:

1. The paired header file
2. Other headers from your project
3. 3rd party library headers
4. Standard library headers

The headers for each grouping should be sorted alphabetically.

###### Header guards: (Good practice to use and learn)

Header guards are conditional compilation directives that take the following form: 

```cpp
#ifndef SOME_UNIQUE_NAME_HERE
#define SOME_UNIQUE_NAME_HERE

// your declarations (and certain types of definitions) here

#endif
```

All of your header files should have header guards on them. 

**Best practice:** Favor header guards over `#pragma once` for maximum portability.

## Namespaces

C++ allows us to define our own namespaces via the `namespace` keyword. Note the use of blocks inside the namespace for defining functions belonging to it.

```cpp
#include <iostream>

namespace foo // define a namespace named foo
{
    // This doSomething() belongs to namespace foo
    int doSomething(int x, int y)
    {
        return x + y;
    }
}

namespace goo // define a namespace named goo
{
    // This doSomething() belongs to namespace goo
    int doSomething(int x, int y)
    {
        return x - y;
    }
}

int main()
{
    std::cout << foo::doSomething(4, 3) << '\n'; // use the doSomething() that exists in namespace foo
    return 0;
}
```

It’s legal to declare namespace blocks in multiple locations (either across multiple files, or multiple places within the same file). All declarations within the namespace are considered part of the namespace.

Namespaces can be nested inside other namespaces. For example:

```cpp
#include <iostream>

namespace foo
{
    namespace goo // goo is a namespace inside the foo namespace
    {
        int add(int x, int y)
        {
            return x + y;
        }
    }
}

int main()
{
    std::cout << foo::goo::add(1, 2) << '\n';
    return 0;
}
```

In applications, namespaces can be used to separate application-specific code from code that might be reusable later (e.g. math functions). For example, physical and math functions could go into one namespace (e.g. `math::`). Language and localization functions in another (e.g. `lang::`).

### Unnamed and inline namespaces:

An **inline namespace** is a namespace that is typically used to version content.

```cpp
#include <iostream>

inline namespace v1 // declare an inline namespace named v1
{
    void doSomething()
    {
        std::cout << "v1\n";
    }
}

namespace v2 // declare a normal namespace named v2
{
    void doSomething()
    {
        std::cout << "v2\n";
    }
}

int main()
{
    v1::doSomething(); // calls the v1 version of doSomething()
    v2::doSomething(); // calls the v2 version of doSomething()

    doSomething(); // calls the inline version of doSomething() (which is v1)

    return 0;
}
```



## Inlining

Write the code as part of an existing function. Called writing code “in-place” or “inline. 

Writing functions provides many potential benefits. 

However, one downside of using a function is that every time a function is called, there is a certain amount of performance overhead that occurs.

For functions that are large and/or perform complex tasks, the overhead of the function call is typically insignificant compared to the amount of time the function takes to run.

### Inline expansion:

**Inline expansion** is a process where a function call is replaced by the code from the called function’s definition.

Beyond removing the cost of function call overhead, inline expansion can also allow the compiler to optimize the resulting code more efficiently.

However, inline expansion has its own potential cost: if the body of the function being expanded takes more instructions than the function call being replaced, then each inline expansion will cause the executable to grow larger. Larger executables tend to be slower (due to not fitting as well in caches). 

**Tip**: Modern optimizing compilers make the decision about when functions should be expanded inline.

**Best practice**: Do not use the `inline` keyword to request inline expansion for your functions.

**Best practice**: Avoid the use of the `inline` keyword for functions unless you have a specific, compelling reason to do so.

## Constexpr and Consteval functions

**Constexpr functions can be evaluated at compile-time**

To make a function a constexpr function, we simply use the `constexpr` keyword in front of the return type.

**Best practice**: Use a `constexpr` return type for functions that need to return a compile-time constant.

Constexpr functions are implicitly inline. 

**Key insight: **Allowing functions with a constexpr return type to be evaluated at either compile-time or runtime was allowed so that a single function can serve both cases. Otherwise, you’d need to have separate functions (a function with a constexpr return type, and a function with a non-constexpr return type). This would not only require duplicate code, the two functions would also need to have different names!

Check if compiled: (C++20)

```cpp
#include <type_traits> // for std::is_constant_evaluated
constexpr int someFunction()
{
    if (std::is_constant_evaluated()) // if compile-time evaluation
        // do something
    else // runtime evaluation
        // do something else
}
```

### Consteval:

C++20 introduces the keyword **consteval**, which is used to indicate that a function *must* evaluate at compile-time, otherwise a compile error will result. Such functions are called **immediate functions**. 

**Best practice**: Use `consteval` if you have a function that must run at compile-time for some reason (e.g. performance).

```cpp
#include <iostream>

consteval int greater(int x, int y) // function is now consteval
{
    return (x > y ? x : y);
}

int main()
{
    constexpr int g { greater(5, 6) };            // ok: will evaluate at compile-time
    std::cout << greater(5, 6) << " is greater!\n"; // ok: will evaluate at compile-time

    int x{ 5 }; // not constexpr
    std::cout << greater(x, 6) << " is greater!\n"; // error: consteval functions must evaluate at compile-time

    return 0;
}
```

## Overloading

**Function overloading** allows us to create multiple functions with the same name, so long as each identically named function has different parameter types (or the functions can be otherwise differentiated). Each function sharing a name (in the same scope) is called an **overloaded function** (sometimes called an **overload** for short).

```cpp
int add(int x, int y) // integer version
{
    return x + y;
}

double add(double x, double y) // floating point version
{
    return x + y;
}

int main()
{
    return 0;
}
```

**Key insight**: Functions can be overloaded so long as each overloaded function can be differentiated by the compiler. If an overloaded function can not be differentiated, a compile error will result.

**Best practice**: Use function overloading to make your program simpler.

In order for a program using overloaded functions to compile, two things have to be true:

1. Each overloaded function has to be differentiated from the others. We discuss how functions can be differentiated in lesson [8.10 -- Function overload differentiation](https://www.learncpp.com/cpp-tutorial/function-overload-differentiation/).
2. Each call to an overloaded function has to resolve to an overloaded function. We discuss how the compiler matches function calls to overloaded functions in lesson [8.11 -- Function overload resolution and ambiguous matches](https://www.learncpp.com/cpp-tutorial/function-overload-resolution-and-ambiguous-matches/).

### Differentiation

Overloaded functions that are not properly differentiated will cause the compiler to issue a compile error.

![image-20221011104053841](C:\Users\Johan\AppData\Roaming\Typora\typora-user-images\image-20221011104053841.png)

Because type aliases (or typedefs) are not distinct types, overloaded functions using type aliases are not distinct from overloads using the aliased type. For example, all of the following overloads are not differentiated (and will result in a compile error):

```cpp
typedef int Height; // typedef
using Age = int; // type alias

void print(int value);
void print(Age value); // not differentiated from print(int)
void print(Height value); // not differentiated from print(int)
```

A function’s **type signature** (generally called a **signature**) is defined as the parts of the function header that are used for differentiation of the function. In C++, this includes the function name, number of parameter, parameter type, and function-level qualifiers. It notably does *not* include the return type.

### Overload Resolution

The compiler has to determine which overloaded function is the best match. The process of matching function calls to a specific overloaded function is called **overload resolution**.

In simple cases where the type of the function arguments and type of the function parameters match exactly, this is (usually) straightforward.

Just because there is no exact match here doesn’t mean a match can’t be found -- after all, a `char` or `long` can be implicitly type converted to an `int` or a `double`. But which is the best conversion to make in each case?

When a function call is made to an overloaded function, the compiler steps through a sequence of rules to determine which (if any) of the overloaded functions is the best match.

- No matching functions were found. The compiler moves to the next step in the sequence.
- A single matching function was found. This function is considered to be the best match. The matching process is now complete, and subsequent steps are not executed.
- More than one matching function was found. The compiler will issue an ambiguous match compile error. We’ll discuss this case further in a bit.

If the compiler reaches the end of the entire sequence without finding a match, it will generate a compile error that no matching overloaded function could be found for the function call.

**Key insight**: Matches made by applying numeric promotions take precedence over any matches made by applying numeric conversions.

Matches made via the trivial conversions are considered exact matches.

Example:

```cpp
void print(int)
{
}

void print(double)
{
}

int main()
{
    print('a'); // promoted to match print(int)
    print(true); // promoted to match print(int)
    print(4.5f); // promoted to match print(double)

    return 0;
}
```

#### Ambigious matches

An **ambiguous match** occurs when the compiler finds two or more functions that can be made to match in the same step. When this occurs, the compiler will stop matching and issue a compile error stating that it has found an ambiguous function call.

**Key insight:** If the compiler finds multiple matches in a given step, an ambiguous function call will result. This means no match from a given step is considered to be better than any other match from the same step.

##### Resolving ambiguous matches

Because ambiguous matches are a compile-time error, an ambiguous match needs to be disambiguated before your program will compile. There are a few ways to resolve ambiguous matches:

1. Often, the best way is simply to define a new overloaded function that takes parameters of exactly the type you are trying to call the function with. Then C++ will be able to find an exact match for the function call.
2. Alternatively, explicitly cast the ambiguous argument(s) to match the type of the function you want to call. For example, to have `print(0)` match `print(unsigned int)` in the above example, you would do this:

```cpp
int x{ 0 };
print(static_cast<unsigned int>(x)); // will call print(unsigned int)
```

### Function Templates

A **function template** is a function-like definition that is used to generate one or more overloaded functions, each with a different set of actual types. This is what will allow us to create functions that can work with many different types.

Having to create overloaded functions with the same implementation for each set of parameter types we want to support is a maintenance headache, a recipe for errors, and a clear violation of the DRY (don’t repeat yourself) principle.

Instead of manually creating a bunch of mostly-identical functions or classes (one for each set of different types), we instead create a single `template`. 

Once a template is defined, the compiler can use the template to generate as many overloaded functions (or classes) as needed, each using different actual types!

Making one, example:

**Best practice**: Use a single capital letter (starting with T) to name your template types (e.g. T, U, V, etc…)

```cpp
template <typename T> // this is the template parameter declaration
T max(T x, T y) // this is the function template definition for max<T>
{
    return (x > y) ? x : y;
}
```

We start with the keyword `template`, which tells the compiler that we’re creating a template.

Next, we specify all of the template types that our template will use inside angled brackets (`<>`). 

For each template type, we use the keyword `typename` or `class`, followed by the name of the template type (e.g. `T`).

**As an aside:** There is no difference between the `typename` and `class` keywords in this context. You will often see people use the `class` keyword since it was introduced into the language earlier. However, we prefer the newer `typename` keyword, because it makes it clearer that the template type can be replaced by any type (such as a fundamental type), not just class types.

#### Using a function template:

Function templates are not actually functions -- their code isn’t compiled or executed directly. Instead, function templates have one job: to generate functions (that are compiled and executed).

Example:

```cpp
#include <iostream>

template <typename T>
T max(T x, T y)
{
    return (x > y) ? x : y;
}

int main()
{
    std::cout << max<int>(1, 2) << '\n'; // instantiates and calls function max<int>(int, int)

    return 0;
}
```

When the compiler encounters the function call `max<int>(1, 2)`, it will determine that a function definition for `max<int>(int, int)` does not already exist. Consequently, the compiler will use our `max<T>` function template to create one.

The process of creating functions (with specific types) from function templates (with template types) is called **function template instantiation** (or **instantiation** for short).

The process for instantiating a function is simple: the compiler essentially clones the function template and replaces the template type (`T`) with the actual type we’ve specified (`int`).

Optional: different ways to call to deduce or specify funciton to call

**Best practice**: Favor the normal function call syntax when using function templates.

It’s possible to create function templates that have both template types and non-template type parameters. The template parameters can be matched to any type, and the non-template parameters work like the parameters of normal functions.

**Best practice**: Use function templates to write generic code that can work with a wide variety of types whenever you have the need.

Once you get used to writing function templates, you’ll find they actually don’t take much longer to write than functions with actual types. Function templates can significantly reduce code maintenance and errors by minimizing the amount of code that needs to be written and maintained.

Function templates do have a few drawbacks, and we would be remiss not to mention them. First, the compiler will create (and compile) a function for each function call with a unique set of argument types. So while function templates are compact to write, they can expand into a crazy amount of code, which can lead to code bloat and slow compile times. The bigger downside of function templates is that they tend to produce crazy-looking, borderline unreadable error messages that are much harder to decipher than those of regular functions. 

These drawbacks are fairly minor compared with the power and safety that templates bring to your programming toolkit, so use templates liberally anywhere you need type flexibility! A good rule of thumb is to create normal functions at first, and then convert them into function templates if you find you need an overload for different parameter types.

**Note:** when the compiler is doing template argument deduction, it won’t do any type conversions. So can't mix different types in arguments without explicit casting.

**Extra Note:** Can create templates of differtent types directly

```cpp
#include <iostream>

template <typename T, typename U> // We're using two template type parameters named T and U
T max(T x, U y) // x can resolve to type T, and y can resolve to type U
{
    return (x > y) ? x : y; // uh oh, we have a narrowing conversion problem here
}

int main()
{
    std::cout << max(2, 3.5) << '\n';

    return 0;
}
```

**Best practice**: Feel free to use abbreviated function templates if each auto parameter should be an independent template type (and your language standard is set to C++20 or newer).

```cpp
auto max(auto x, auto y)
{
    return (x > y) ? x : y;
}
```