6. Data types

One byte is 8 bits!

**Key insight:** In C++, we typically work with “byte-sized” chunks of data.

The data type declares a piece of memory to be interpreted as a specific type. 

To help determine how expressions should evaluate and where they can be used, all expressions in C++ have two properties: a type and a value category.

## Object sizes:

Most objects actually take up more than 1 byte of memory. A single object may use 2, 4, 8, or even more consecutive memory addresses. The amount of memory that an object uses is based on its data type. 

To generalize, an object with *n* bits (where n is an integer) can hold $2^n$ unique values.

**Key insight**: New programmers often focus too much on optimizing their code to use as little memory as possible. In most cases, this makes a negligible difference. Focus on writing maintainable code, and optimize only when and where the benefit will be substantive.

 You may be surprised to find that the size of a given data type is dependent on the compiler and/or the computer architecture! These are the minimum size in C++:

![image-20221004100702051](C:\Users\Johan\AppData\Roaming\Typora\typora-user-images\image-20221004100702051.png)

### Sizeof operator:

```cpp
sizeof();
```

Unary operator. 

Input is either type or variable.

Output is is its size in bytes.

Note that you can not use the *sizeof* operator on the *void* type, since it has no size.

#### Scienfitic Notation:

Written as:

1.2e4 or 1.2e-5

## Fundamental Data types:

C++ comes with built-in support for many different data types. These are called **fundamental data types**.

![image-20221004095912020](C:\Users\Johan\AppData\Roaming\Typora\typora-user-images\image-20221004095912020.png)



### Void:

*Void* basically means "no type". 

Used to indicate a function not returning a value. 

**Best practice:** Use an empty parameter list instead of *void* to indicate that a function has no parameters. 

### Signed integers:

An **integer** is an integral type that can represent positive and negative whole numbers. 4 types in C++:

![image-20221004101248251](C:\Users\Johan\AppData\Roaming\Typora\typora-user-images\image-20221004101248251.png)

Defined the following way:

```cpp
short s;      // prefer "short" instead of "short int" 			127
int i;														32 767	
long l;       // prefer "long" instead of "long int"			2 147 483 647 
long long ll; // prefer "long long" instead of "long long int"	 loooong
```

**Best practice:** Prefer the shorthand types that do not use the *int* suffix or signed prefix.

The range of the types are $2^{n-1}-1$. 

**Warning:** Signed integer overflow will result in undefined behavior.

#### Integer division:

When doing division with two integers (called **integer division**), C++ always produces an integer result. Since integers can’t hold fractional values, any fractional portion is simply dropped (not rounded!).

#### Unsigned integers:

**Unsigned integers** are integers that can only hold non-negative whole numbers.

```cpp
unsigned short us;
unsigned int ui;
unsigned long ul;
unsigned long long ull;
```

When no negative numbers are required, unsigned integers are well-suited for networking and systems with little memory, because unsigned integers can store more positive numbers without taking up extra memory.

Many developers (and some large development houses, such as Google) believe that developers should generally avoid unsigned integers.

Unexpected behavior can result when you mix signed and unsigned integers.

**Best practice**: Favor signed numbers over unsigned numbers for holding quantities (even quantities that should be non-negative) and mathematical operations. Avoid mixing signed and unsigned numbers.

##### Why isn’t the size of the integer variables fixed?

The short answer is that this goes back to C, when computers were slow and performance was of the utmost concern. C opted to intentionally leave the size of an integer open so that the compiler implementers could pick a size for int that performs best on the target computer architecture.

**Fixed-width integers**: To address the above issues, C99 defined a set of **fixed-width integers** (in the stdint.h header) that are guaranteed to be the same size on any architecture.

![image-20221004102627960](C:\Users\Johan\AppData\Roaming\Typora\typora-user-images\image-20221004102627960.png)

Need to include: <cstdint>

Just because your CPU can process a given type faster doesn’t mean your program will be faster overall -- modern programs are often constrained by memory usage rather than CPU, and the larger memory footprint may slow your program more than the faster CPU processing accelerates it. It’s hard to know without actually measuring. 

**Best practice:**

- Prefer `int` when the size of the integer doesn’t matter (e.g. the number will always fit within the range of a 2-byte signed integer). For example, if you’re asking the user to enter their age, or counting from 1 to 10, it doesn’t matter whether int is 16 or 32 bits (the numbers will fit either way). This will cover the vast majority of the cases you’re likely to run across.
- Prefer `std::int#_t` when storing a quantity that needs a guaranteed range.
- Prefer `std::uint#_t` when doing bit manipulation or where well-defined wrap-around behavior is required.

Avoid the following when possible:

- Unsigned types for holding quantities
- The 8-bit fixed-width integer types
- The fast and least fixed-width types
- Any compiler-specific fixed-width integers -- for example, Visual Studio defines __int8, __int16, etc…

##### **What is std::size_t?**

The answer is that sizeof (and many functions that return a size or length value) return a value of type *std::size_t*. **std::size_t** is defined as an unsigned integral type, and it is typically used to represent the size or length of objects.

## Floating Point Numbers

The *floating* part of the name *floating point* refers to the fact that the decimal point can “float”; that is, it can support a variable number of digits before and after the decimal point. 

Floating point data types are always signed (can hold positive and negative values).

**Best practice:** Favor double over float unless space is at a premium, as the lack of precision in a float will often lead to inaccuracies.

![image-20221004103554863](C:\Users\Johan\AppData\Roaming\Typora\typora-user-images\image-20221004103554863.png)

```cpp
float fValue;
double dValue;
long double ldValue;
```

When using floating point literals, always include at least one decimal place (even if the decimal is 0). This helps the compiler understand that the number is a floating point number and not an integer.

**Best practice:** Always make sure the type of your literals match the type of the variables they’re being assigned to or used to initialize. Otherwise an unnecessary conversion will result, possibly with a loss of precision.

### Range:

![image-20221004103811619](C:\Users\Johan\AppData\Roaming\Typora\typora-user-images\image-20221004103811619.png)

The **precision** of a floating point number defines how many *significant digits* it can represent without information loss.

#### NaN and Inf:

There are two special categories of floating point numbers. The first is **Inf**, which represents infinity. Inf can be positive or negative. The second is **NaN**, which stands for “Not a Number”. 

## Booleans

Boolean variables are variables that can have only two possible values: *true*, and *false*.

```cpp
bool b1 { true };
bool b2 { false };
b1 = false;
bool b3 {}; // default initialize to false
```

When we print Boolean values, std::cout prints *0* for *false*, and *1* for *true*. 

To get *true* and *false* use: std::cout << std::boolalpha;

## Characters

The char data type is an integral type, meaning the underlying value is stored as an integer. The integer stored by a `char` variable are intepreted as an `ASCII character`.

You can initialize char variables using character literals:

```cpp
char ch2{ 'a' }; // initialize with code point for 'a' (stored as integer 97) (preferred)
char ch1{ 97 }; // initialize with integer 97 ('a') (not preferred)
```

When using std::cout to print a char, std::cout outputs the char variable as an ASCII character, eg. 97 becomes 'a'. 

If you want to read in more than one char at a time (e.g. to read in a name, word, or sentence), you’ll want to use a string instead of a char. A **string** is a collection of sequential characters (and thus, a string can hold multiple symbols).

Single chars are always put in single quotes

Text put between double quotes (e.g. “Hello, world!”) is treated as a string.

**Best practice:** Put stand-alone chars in single quotes (e.g. ‘t’ or ‘\n’, not “t” or “\n”). This helps the compiler optimize more effectively.

### Escape Sequences: (TODO:)

![image-20221004110704612](C:\Users\Johan\AppData\Roaming\Typora\typora-user-images\image-20221004110704612.png)

## Strings

Modern C++ supports two different types of strings: std::string (as part of the standard library), and C-style strings (natively, as inherited from the C language). It turns out that std::string is implemented using C-style strings.

### C-Style Strings

A **C-style string** is simply an array of characters that uses a null terminator. A **null terminator** is a special character (‘\0’, ascii code 0) used to indicate the end of the string. More generically, A C-style string is called a **null-terminated string**.

Declared the follwoing way:

```cpp
char myString[]{ "string" };
```

Although “string” only has 6 letters, C++ automatically adds a null terminator to the end of the string for us (we don’t need to include it ourselves). Consequently, myString is actually an array of length 7!

When declaring strings in this manner, it is a good idea to use [] and let the compiler calculate the length of the array. That way if you change the string later, you won’t have to manually adjust the array length.

One important point to note is that C-style strings follow *all* the same rules as arrays. This means you can initialize the string upon creation, but you can not assign values to it using the assignment operator after that!

```cpp
char myString[]{ "string" }; // ok
myString = "rope"; // not ok!
```

#### Output:

When printing a C-style string, std::cout prints characters until it encounters the null terminator. If you accidentally overwrite the null terminator in a string (e.g. by assigning something to myString[6]), you’ll not only get all the characters in the string, but std::cout will just keep printing everything in adjacent memory slots until it happens to hit a 0!

#### Input:

The recommended way of reading C-style strings using `std::cin` is as follows:

```cpp
#include <iostream>
#include <iterator> // for std::size

int main()
{
    char name[255] {}; // declare array large enough to hold 254 characters + null terminator
    std::cout << "Enter your name: ";
    std::cin.getline(name, std::size(name));
    std::cout << "You entered: " << name << '\n';

    return 0;
}
```

This call to cin.getline() will read up to 254 characters into name (leaving room for the null terminator!). Any excess characters will be discarded. In this way, we guarantee that we will not overflow the array!

#### Manipulating C-style strings

C++ provides many functions to manipulate C-style strings as part of the <cstring> header. Here are a few of the most useful:

strcpy() allows you to copy a string to another string. More commonly, this is used to assign a value to a string:

```cpp
#include <cstring>
#include <iostream>

int main()
{
    char source[]{ "Copy this!" };
    char dest[50];
    std::strcpy(dest, source);
    std::cout << dest << '\n'; // prints "Copy this!"

    return 0;
}
```

However, strcpy() can easily cause array overflows if you’re not careful!

Many programmers recommend using strncpy() instead, which allows you to specify the size of the buffer, and ensures overflow doesn’t occur. Unfortunately, strncpy() doesn’t ensure strings are null terminated, which still leaves plenty of room for array overflow.

Another useful function is the strlen() function, which returns the length of the C-style string (without the null terminator).

```cpp
#include <iostream>
#include <cstring>
#include <iterator> // for std::size

int main()
{
    char name[20]{ "Alex" }; // only use 5 characters (4 letters + null terminator)
    std::cout << "My name is: " << name << '\n';
    std::cout << name << " has " << std::strlen(name) << " letters.\n";
    std::cout << name << " has " << std::size(name) << " characters in the array.\n"; // use sizeof(name) / sizeof(name[0]) if not C++17 capable

    return 0;
}
```

Other useful functions:
strcat() -- Appends one string to another (dangerous)
strncat() -- Appends one string to another (with buffer length check)
strcmp() -- Compare two strings (returns 0 if equal)
strncmp() -- Compare two strings up to a specific number of characters (returns 0 if equal)

#### Don’t use C-style strings

It is important to know about C-style strings because they are used in a lot of code. 

Use std::string (defined in the <string> header) instead. std::string is easier, safer, and more flexible. In the rare case that you do need to work with fixed buffer sizes and C-style strings (e.g. for memory-limited devices), we’d recommend using a well-tested 3rd party string library designed for the purpose, or `std::string_view`.

**Rule**: Use `std::string` or `std::string_view` (next lesson) instead of C-style strings.

### std::string

In order to use string include the following:

```cpp
#include <string>
```

C-style strings are fast, but they’re not as easy to use and as safe as `std::string`.

A `std::string` provides some useful guarantees about the string data it manages:

- The string data will be valid for as long as the string object is alive, and cleaned up when the string object dies.
- The string’s value can only be modified by the string object.
- The string’s value can be modified without affecting other objects (for non-const strings).

A `std::string` object has no control over what kind of string is used to initialize it (that is the caller’s responsibility) -- the caller could destroy or modify the initialization string immediately after the `std::string` object is initialized. Post-initialization, the string object can not rely on the initializer in any way, otherwise the above guarantees could be violated.

However, in some cases, we don’t need these benefits (particularly for const `std::string` objects, which can’t modify their value). Consider the case where we we know a `std::string` won’t outlive it’s initialization string, and that the initialization string won’t be modified. In such cases, we’re paying a high cost (making a copy of the initialization string) for benefits we don’t need (independence from the initialization string).

Unlike C-style strings and `std::string`, `std::string_view` doesn’t use null terminators to mark the end of the string. Rather, it knows where the string ends because it keeps track of its length. Safe to use std::size.

#### std::string_view

C++17 introduces another way of using strings, `std::string_view`, which lives in the <string_view> header.

Unlike `std::string`, which keeps its own copy of the string, `std::string_view` provides a *view* of a string that is defined elsewhere.

Because `std::string_view` doesn’t create a copy of the string, if we change the viewed string, the changes are reflected in the `std::string_view`.

**Best practice**: Prefer `std::string_view` over `std::string` and C-style strings when you only need read-only access to a string (unless you can’t guarantee the string being viewed will stay alive for the lifetime of the `std::string_view`, in which case you should prefer `std::string`).

A `std::string_view`‘s lifetime is independent of lifetime of the string it is viewing (meaning the string being viewed can be destroyed before the `std::string_view` object). If this happens, then accessing the `std::string_view` will cause undefined behavior.

**Warning:** Make sure that the underlying string viewed with a `std::string_view` does not go out of scope and isn’t modified while using the std::string_view.

**Note:** Being a relatively recent feature, `std::string_view` isn’t implemented as well as it could be.

##### View modification functions

`std::string_view` contains functions that let us manipulate the *view* of the string. This allows us to change the view without modifying the viewed string. 

The functions for this are `remove_prefix`, which removes characters from the left side of the view, and `remove_suffix`, which removes characters from the right side of the view.

```cpp
#include <iostream>
#include <string_view>

int main()
{
  std::string_view str{ "Peach" };

  std::cout << str << '\n';

  // Ignore the first character.
  str.remove_prefix(1);

  std::cout << str << '\n';

  // Ignore the last 2 characters.
  str.remove_suffix(2);

  std::cout << str << '\n';

  return 0;
}
```

Unlike real curtains, a `std::string_view` cannot be opened back up. Once you shrink the area, the only way to re-widen it is to reset the view by reassigning the source string to it again.

#### Pass to function

One question that often comes up: is it better to pass strings by `const std::string&` (reference) or `std::string_view`?

If we want to write a function that takes a string parameter, making the parameter a `std::string_view` is the most flexible choice, because it can work efficiently with C-style string arguments (including string literals), `std::string` arguments (which will implicitly convert to `std::string_view`), and `std::string_view` arguments:

```cpp
#include <iostream>
#include <string>
#include <string_view>

void printSV(std::string_view sv)
{
    std::cout << sv << '\n';
}

int main()
{
    std::string s{ "Hello, world" };
    std::string_view sv { s };

    printSV(s);              // ok: pass std::string
    printSV(sv);             // ok: pass std::string_view
    printSV("Hello, world"); // ok: pass C-style string literal

    return 0;
```

**Best practice**: Prefer passing strings using `std::string_view` (by value) instead of `const std::string&`, unless your function calls other functions that require C-style strings or std::string parameters.

## Compound Data Types

**Compound data types** (also sometimes called **composite data types**) are data types that can be constructed from fundamental data types (or other compound data types). Each compound data type has its own unique properties as well.

C++ supports the following compound types:

- Functions
- Arrays
- Pointer types:
  - Pointer to object
  - Pointer to function
- Pointer to member types:
  - Pointer to data member
  - Pointer to member function
- Reference types:
  - L-value references
  - R-value references
- Enumerated types:
  - Unscoped enumerations
  - Scoped enumerations
- Class types:
  - Structs
  - Classes
  - Unions

**The value category of an expression**: The **value category** of an expression (or subexpression) indicates whether an expression resolves to a value, a function, or an object of some kind.

Prior to C++11, there were only two possible value categories: `lvalue` and `rvalue`.

In C++11, three additional value categories (`glvalue`, `prvalue`, and `xvalue`) were added to support a new feature called `move semantics`.

```cpp
int main()
{
    int x{};

    // Assignment requires the left operand to be a modifiable lvalue expression and the right operand to be an rvalue expression
    x = 5; // valid: x is a modifiable lvalue expression and 5 is an rvalue expression
    5 = x; // error: 5 is an rvalue expression and x is a modifiable lvalue expression

    return 0;
}
```

### Lvalue

An **lvalue** (pronounced “ell-value”, short for “left value” or “locator value”, and sometimes written as “l-value”) is an expression that evaluates to an identifiable object or function (or bit-field).

Entities with identities can be accessed via an identifier, reference, or pointer, and typically have a lifetime longer than a single expression or statement.

```cpp
#include <iostream>

int main()
{
    int x{};
    const double d{};

    int y { x }; // x is a modifiable lvalue expression
    const double e { d }; // d is a non-modifiable lvalue expression

    return 0;
}
```

### Rvalue

An **rvalue** (pronounced “arr-value”, short for “right value”, and sometimes written as `r-value`) is an expression that is not an l-value. Commonly seen rvalues include literals (except C-style string literals, which are lvalues) and the return value of functions and operators. Rvalues aren’t identifiable (meaning they have to be used immediately), and only exist within the scope of the expression in which they are used.

```cpp
#include <iostream>

int return5()
{
    return 5;
}

int main()
{
    int x{ 5 }; // 5 is an rvalue expression
    const double d{ 1.2 }; // 1.2 is an rvalue expression

    int y { x }; // x is a modifiable lvalue expression
    const double e { d }; // d is a non-modifiable lvalue expression
    int z { return5() }; // return5() is an rvalue expression (since the result is returned by value)

    int w { x + 1 }; // x + 1 is an rvalue expression
    int q { static_cast<int>(d) }; // the result of static casting d to an int is an rvalue expression

    return 0;
}
```

lvalues will implicitly convert to rvalues, so an lvalue can be used wherever an rvalue is required.

**Key insight**: As a rule of thumb to identify lvalue and rvalue expressions:

- lvalues expressions are those that evaluate to variables or other identifiable objects that persist beyond the end of the expression.
- rvalues expressions are those that evaluate to literals or the returned value of functions and operators that are discarded at the end of the expression.

### Lvalue reference

In C++, a **reference** is an alias for an existing object. Once a reference has been defined, any operation on the reference is applied to the object being referenced.

**Key insight:** A reference is essentially identical to the object being referenced.

This means we can use a reference to read or modify the object being referenced. Although references might seem silly, useless, or redundant at first, references are used everywhere in C++.

To declare an lvalue reference type, we use an ampersand (&) in the type declaration:

```cpp
int      // a normal int type
int&     // an lvalue reference to an int object
double&  // an lvalue reference to a double object
```

#### Lvalue reference variables

One of the things we can do with an lvalue reference type is create an lvalue reference variable. An **lvalue reference variable** is a variable that acts as a reference to an lvalue (usually another variable).

```cpp
#include <iostream>

int main()
{
    int x { 5 };    // x is a normal integer variable
    int& ref { x }; // ref is an lvalue reference variable that can now be used as an alias for variable x

    std::cout << x << '\n';  // print the value of x (5)
    std::cout << ref << '\n'; // print the value of x via ref (5)

    return 0;
}
```

x and ref are now aliases.

**Best practice**: When defining a reference, place the ampersand next to the type (not the reference variable’s name).

Much like constants, all references must be initialized.

When a reference is initialized with an object (or function), we say it is **bound** to that object (or function). The process by which such a reference is bound is called **reference binding**.

Lvalue references must be bound to a *modifiable* lvalue.

In most cases, the type of the reference must match the type of the referent.

Once initialized, a reference in C++ cannot be **reseated**, meaning it cannot be changed to reference another object.

Reference variables follow the same scoping and duration rules that normal variables do.

When an object being referenced is destroyed before a reference to it, the reference is left referencing an object that no longer exists. Such a reference is called a **dangling reference**. Accessing a dangling reference leads to undefined behavior.

#### References aren't objects

Perhaps surprisingly, references are not objects in C++. A reference is not required to exist or occupy storage. If possible, the compiler will optimize references away by replacing all occurrences of a reference with the referent. However, this isn’t always possible, and in such cases, references may require storage.

#### **Lvalue reference to const**

By using the `const` keyword when declaring an lvalue reference, we tell an lvalue reference to treat the object it is referencing as const. Such a reference is called an **lvalue reference to a const value** (sometimes called a **reference to const** or a **const reference**).

**Best practice**: Favor `lvalue references to const` over `lvalue references to non-const` unless you need to modify the object being referenced.

**Key insight**: 

- Lvalue references can only bind to modifiable lvalues. 

- Lvalue references to const can bind to modifiable lvalues, non-modifiable lvalues, and rvalues. This makes them a much more flexible type of reference.

### Using lvalues - Pass by lvalue reference

When we call a function, we make a copy of our argument’s value, only to use it briefly and then destroy it! Fortunately, because fundamental types are cheap to copy, this isn’t a problem.

Class types are usually expensive to copy. Whenever possible, we want to avoid making unnecessary copies of objects that are expensive to copy, especially when we will destroy those copies almost immediately.

Suboptimal program using std::string:

```cpp
#include <iostream>
#include <string>

void printValue(std::string y)
{
    std::cout << y << '\n';
} // y is destroyed here

int main()
{
    std::string x { "Hello, world!" }; // x is a std::string

    printValue(x); // x is passed by value (copied) into parameter y (expensive)

    return 0;
}
```

One way to avoid making an expensive copy of an argument when calling a function is to use `pass by reference` instead of `pass by value`. When using **pass by reference**, we declare a function parameter as a reference type (or const reference type) rather than as a normal type. When the function is called, each reference parameter is bound to the appropriate argument. Because the reference acts as an alias for the argument, no copy of the argument is made.

```cpp
#include <iostream>
#include <string>

void printValue(std::string& y) // type changed to std::string&
{
    std::cout << y << '\n';
} // y is destroyed here

int main()
{
    std::string x { "Hello, world!" };

    printValue(x); // x is now passed by reference into reference parameter y (inexpensive)

    return 0;
}
```

**Key insight**: Pass by reference allows us to pass arguments to a function without making copies of those arguments each time the function is called.

#### Pass by reference allows us to change the value of an argument

When an object is passed by value, the function parameter receives a copy of the argument. This means that any changes to the value of the parameter are made to the copy of the argument, not the argument itself:

```cpp
#include <iostream>

void addOne(int y) // y is a copy of x
{
    ++y; // this modifies the copy of x, not the actual object x
}

int main()
{
    int x { 5 };

    std::cout << "value = " << x << '\n';

    addOne(x);

    std::cout << "value = " << x << '\n'; // x has not been modified

    return 0;
}
```

However, since a reference acts identically to the object being referenced, when using pass by reference, any changes made to the reference parameter *will* affect the argument:

```cpp
#include <iostream>

void addOne(int& y) // y is bound to the actual object x
{
    ++y; // this modifies the actual object x
}

int main()
{
    int x { 5 };

    std::cout << "value = " << x << '\n';

    addOne(x);

    std::cout << "value = " << x << '\n'; // x has been modified

    return 0;
}
```

**Key insight**: Passing values by reference to non-const allows us to write functions that modify the value of arguments passed in.

**Pass by reference to non-const can only accept modifiable lvalue arguments**

Passing by const reference offers the same primary benefit as pass by reference (avoiding making a copy of the argument), while also guaranteeing that the function can *not* change the value being referenced.

```cpp
void addOne(const int& ref)
{
    ++ref; // not allowed: ref is const
}
```

**Best practice:** Favor passing by const reference over passing by non-const reference unless you have a specific reason to do otherwise (e.g. the function needs to change the value of an argument).

**Best practice:** Pass fundamental types by value, and class (or struct) types by const reference.

To read: the cost of passing by value vs reference 

**Best practice:** Prefer pass by value for objects that are cheap to copy, and pass by const reference for objects that are expensive to copy. If you’re not sure whether an object is cheap or expensive to copy, favor pass by const reference.

## Pointers

A **pointer** is an object that holds a *memory address* (typically of another variable) as its value. This allows us to store the address of some other object to use later.

**Best practice:** Favor references over pointers unless the additional capabilities provided by pointers are needed.

**As an aside:** In modern C++, the pointers we are talking about here are sometimes called “raw pointers” or “dumb pointers”, to help differentiate them from “smart pointers” that were introduced into the language more recently. 

Much like reference types are declared using an ampersand (&) character, pointer types are declared using an asterisk (*):

```cpp
int;  // a normal int
int&; // an lvalue reference to an int value

int*; // a pointer to an int value (holds the address of an integer value)
```

**Best practice**: When declaring a pointer type, place the asterisk next to the type name.

**Best practice**: Always initialize your pointers.

Like normal variables, pointers are *not* initialized by default. A pointer that has not been initialized is sometimes called a **wild pointer**. Wild pointers contain a garbage address, and dereferencing a wild pointer will result in undefined behavior. Because of this, you should always initialize your pointers to a known value.

```cpp
int main()
{
    int x{ 5 };

    int* ptr;        // an uninitialized pointer (holds a garbage address)
    int* ptr2{};     // a null pointer (we'll discuss these in the next lesson)
    int* ptr3{ &x }; // a pointer initialized with the address of variable x

    return 0;
}
```

**Author’s note**:  A note on pointer nomenclature: “X pointer” (where X is some type) is a commonly used shorthand for “pointer to an X”. So when we say, “an integer pointer”, we really mean “a pointer to an integer”. This distinction will be valuable when we talk about const pointers.

**Dangling pointers**: Much like a dangling reference, a **dangling pointer** is a pointer that is holding the address of an object that is no longer valid (e.g. because it has been destroyed). Dereferencing a dangling pointer will lead to undefined results.

### Pointers and assignment

We can use assignment with pointers in two different ways:

1. To change what the pointer is pointing at (by assigning the pointer a new address)
2. To change the value being pointed at (by assigning the dereferenced pointer a new value)

```cpp
#include <iostream>

int main()
{
    int x{ 5 };
    int* ptr{ &x }; // ptr initialized to point at x

    std::cout << *ptr << '\n'; // print the value at the address being pointed to (x's address)

    int y{ 6 };
    ptr = &y; // // change ptr to point at y

    std::cout << *ptr << '\n'; // print the value at the address being pointed to (y's address)

    return 0;
}
```

**Key insight**: 

- When we use a pointer without a dereference (`ptr`), we are accessing the address held by the pointer. Modifying this (`ptr = &y`) changes what the pointer is pointing at.

- When we dereference a pointer (`*ptr`), we are accessing the object being pointed at. Modifying this (`*ptr = 6;`) changes the value of the object being pointed at.

Pointers behave similar to references, however

There are some other differences between pointers and references worth mentioning:

- References must be initialized, pointers are not required to be initialized (but should be).
- References are not objects, pointers are.
- References can not be reseated (changed to reference something else), pointers can change what they are pointing at.
- References must always be bound to an object, pointers can point to nothing.
- References are “safe” (outside of dangling references), pointers are inherently dangerous.

#### Size of pointers

The size of a pointer is dependent upon the architecture the executable is compiled for -- a 32-bit executable uses 32-bit memory addresses -- consequently, a pointer on a 32-bit machine is 32 bits (4 bytes). With a 64-bit executable, a pointer would be 64 bits (8 bytes). 

### Address of operator (&)

The **address-of operator** (&) returns the memory address of its operand. This is pretty straightforward:

```cpp
#include <iostream>

int main()
{
    int x{ 5 };
    std::cout << x << '\n';  // print the value of variable x
    std::cout << &x << '\n'; // print the memory address of variable x

    return 0;
}
```

For objects that use more than one byte of memory, address-of will return the memory address of the first byte used by the object.

**Tip**: The & symbol tends to cause confusion because it has different meanings depending on context:

- When following a type name, & denotes an lvalue reference: `int& ref`.
- When used in a unary context in an expression, & is the address-of operator: `std::cout << &x`.
- When used in a binary context in an expression, & is the Bitwise AND operator: `std::cout << x & y`.

### Dereference operator (*)

The most useful thing we can do with an address is access the value stored at that address. The **dereference operator** (*) (also occasionally called the **indirection operator**) returns the value at a given memory address as an lvalue.

### Null pointers

Besides a memory address, there is one additional value that a pointer can hold: a null value. A **null value** (often shortened to **null**) is a special value that means something has no value. When a pointer is holding a null value, it means the pointer is not pointing at anything. Such a pointer is called a **null pointer**.

**Best practice:** Value initialize your pointers (to be null pointers) if you are not initializing them with the address of a valid object.

Much like the keywords `true` and `false` represent Boolean literal values, the **nullptr** keyword represents a null pointer literal. We can use `nullptr` to explicitly initialize or assign a pointer a null value.

```cpp
int main()
{
    int* ptr { nullptr }; // can use nullptr to initialize a pointer to be a null pointer

    int value { 5 };
    int* ptr2 { &value }; // ptr2 is a valid pointer
    ptr2 = nullptr; // Can assign nullptr to make the pointer a null pointer

    someFunction(nullptr); // we can also pass nullptr to a function that has a pointer parameter

    return 0;
}
```

**Best practice**: Use `nullptr` when you need a null pointer literal for initialization, assignment, or passing a null pointer to a function.

Pointers will also implicitly convert to Boolean values: a null pointer converts to Boolean value `false`, and a non-null pointer converts to Boolean value `true`. This allows us to skip explicitly testing for `nullptr` and just use the implicit conversion to Boolean to test whether a pointer is a null pointer.

**Best practice:** A pointer should either hold the address of a valid object, or be set to nullptr. That way we only need to test pointers for null, and can assume any non-null pointer is valid.

**Warning**: When an object is destroyed, any pointers to the destroyed object will be left dangling (they will not be automatically set to `nullptr`). It is your responsibility to detect these cases and ensure those pointers are subsequently set to `nullptr`.

### Constants

#### Pointer to const value

A **pointer to a const value** (sometimes called a `pointer to const` for short) is a (non-const) pointer that points to a constant value.

Because the data type being pointed to is const, the value being pointed to can’t be changed.

However, because a pointer to const is not const itself (it just points to a const value), we can change what the pointer is pointing at by assigning the pointer a new address.

A pointer to const treats the value being pointed to as constant, regardless of whether the object at that address was initially defined as const or not:

```cpp
int main()
{
    int x{ 5 }; // non-const
    const int* ptr { &x }; // ptr points to a "const int"

    *ptr = 6;  // not allowed: ptr points to a "const int" so we can't change the value through ptr
    x = 6; // allowed: the value is still non-const when accessed through non-const identifier x

    return 0;
}
```

#### Const pointer

We can also make a pointer itself constant. A **const pointer** is a pointer whose address can not be changed after initialization.

```cpp
int main()
{
    int x{ 5 };
    int* const ptr { &x }; // const after the asterisk means this is a const pointer

    return 0;
}
```

However, because the *value* being pointed to is non-const, it is possible to change the value being pointed to via dereferencing the const pointer:

```cpp
int main()
{
    int x{ 5 };
    int* const ptr { &x }; // ptr will always point to x

    *ptr = 6; // okay: the value being pointed to is non-const

    return 0;
}
```

#### Const pointer to a const value

Finally, it is possible to declare a **const pointer to a const value** by using the `const` keyword both before the type and after the asterisk:

```cpp
int main()
{
    int value { 5 };
    const int* const ptr { &value }; // a const pointer to a const value

    return 0;
}
```

A const pointer to a const value can not have its address changed, nor can the value it is pointing to be changed through the pointer. It can only be dereferenced to get the value it is pointing at.

Recap:

```cpp
int main()
{
    int value { 5 };

    int* ptr0 { &value };             // ptr0 points to an "int" and is not const itself, so this is a normal pointer.
    const int* ptr1 { &value };       // ptr1 points to a "const int", but is not const itself, so this is a pointer to a const value.
    int* const ptr2 { &value };       // ptr2 points to an "int", but is const itself, so this is a const pointer (to a non-const value).
    const int* const ptr3 { &value }; // ptr3 points to an "const int", and it is const itself, so this is a const pointer to a const value.

    return 0;
}
```

### Pass by adress

It is possible to pass to a function by value or by reference.

C++ provides a third way to pass values to a function, called pass by address. With **pass by address**, instead of providing an object as an argument, the caller provides an object’s *address* (via a pointer). 

The function can then dereference that pointer to access the object whose address was passed.

```cpp
#include <iostream>
#include <string>

void printByValue(std::string val) // The function parameter is a copy of str
{
    std::cout << val << '\n'; // print the value via the copy
}

void printByReference(const std::string& ref) // The function parameter is a reference that binds to str
{
    std::cout << ref << '\n'; // print the value via the reference
}

void printByAddress(const std::string* ptr) // The function parameter is a pointer that holds the address of str
{
    std::cout << *ptr << '\n'; // print the value via the dereferenced pointer
}

int main()
{
    std::string str{ "Hello, world!" };

    printByValue(str); // pass str by value, makes a copy of str
    printByReference(str); // pass str by reference, does not make a copy of str
    printByAddress(&str); // pass str by address, does not make a copy of str

    return 0;
}
```

When the function is called, we can’t just pass in the `str` object -- we need to pass in the address of `str`. The easiest way to do that is to use the address-of operator (&) to get a pointer holding the address of `str`.

Because `ptr` now holds the address of `str`, when the function dereferences `ptr`, it will get the value of `str`, which the function prints to the console.

1. Pass by address does not make a copy of the object being pointed to
2. Pass by address allows the function to modify the argument’s value

When passing a parameter by address, care should be taken to ensure the pointer is not a null pointer before you dereference the value. 

```cpp
#include <iostream>

void print(int* ptr)
{
    if (!ptr) // if ptr is a null pointer, early return back to the caller
        return;

    // if we reached this point, we can assume ptr is valid
    // so no more testing or nesting required

    std::cout << *ptr;
}

int main()
{
	int x{ 5 };

	print(&x);
	print(nullptr);

	return 0;
}
```

### Pass by const reference

Pass by reference has the same benefits as pass by address without the risk of inadvertently dereferencing a null pointer.

```cpp
#include <iostream>
#include <string>

void printByValue(int val) // The function parameter is a copy of the argument
{
    std::cout << val << '\n'; // print the value via the copy
}

void printByReference(const int& ref) // The function parameter is a reference that binds to the argument
{
    std::cout << ref << '\n'; // print the value via the reference
}

void printByAddress(const int* ptr) // The function parameter is a pointer that holds the address of the argument
{
    std::cout << *ptr << '\n'; // print the value via the dereferenced pointer
}

int main()
{
    printByValue(5);     // valid (but makes a copy)
    printByReference(5); // valid (because the parameter is a const reference)
    printByAddress(&5);  // error: can't take address of r-value

    return 0;
}
```

The syntax for pass by reference is natural, as we can just pass in literals or objects. With pass by address, our code ends up littered with ampersands (&) and asterisks (*).

**Best practice**: Prefer pass by reference to pass by address unless you have a specific reason to use pass by address.

Follow this common maxim: “Pass by reference when you can, pass by address when you must”.

### There is only pass by value

While the compiler can often optimize references away entirely, there are cases where this is not possible and a reference is actually needed. References are normally implemented by the compiler using pointers. This means that behind the scenes, pass by reference is essentially just a pass by address (with access to the reference doing an implicit dereference).

And in the previous lesson, we mentioned that pass by address just copies an address from the caller to the called function -- which is just passing an address by value.

Therefore, we can conclude that C++ really passes everything by value! The properties of pass by address (and reference) come solely from the fact that we can dereference the passed address to change the argument, which we can not do with a normal value parameter!

### Return 

We can avoid making an expensive copy by utilizing passing by (const) reference (or pass by address) instead.

We encounter a similar situation when returning by value: a copy of the return value is passed back to the caller. If the return type of the function is a class type, this can be expensive.

#### Return by reference

In cases where we’re passing a class type back to the caller, we may (or may not) want to return by reference instead. **Return by reference** returns a reference that is bound to the object being returned, which avoids making a copy of the return value.

```cpp
#include <iostream>
#include <string>

const std::string& getProgramName() // returns a const reference
{
    static const std::string s_programName { "Calculator" }; // has static duration, destroyed at end of program

    return s_programName;
}

int main()
{
    std::cout << "This program is named " << getProgramName();

    return 0;
}
```

Using return by reference has one major caveat: the programmer *must* be sure that the object being referenced outlives the function returning the reference. Otherwise, the reference being returned will be left dangling (referencing an object that has been destroyed), and use of that reference will result in undefined behavior.

```cpp
    const std::string programName { "Calculator" }; // now a local variable, destroyed when function ends
```

**Warning:** Objects returned by reference must live beyond the scope of the function returning the reference, or a dangling reference will result. Never return a local variable by reference.

Modern compilers will produce a warning or error if you try to return a local variable by reference (so the above program may not even compile), but compilers sometimes have trouble detecting more complicated cases.

**Best practice**: Avoid returning references to non-const local static variables.

More info about what to avoid in https://www.learncpp.com/cpp-tutorial/return-by-reference-and-return-by-address/

#### Return by adress

**Return by address** works almost identically to return by reference, except a pointer to an object is returned instead of a reference to an object. 

The major advantage of return by address over return by reference is that we can have the function return `nullptr` if there is no valid object to return.

The major disadvantage of return by address is that the caller has to remember to do a `nullptr` check before dereferencing the return value, otherwise a null pointer dereference may occur and undefined behavior will result

**Best practice**: Prefer return by reference over return by address unless the ability to return “no object” (using `nullptr`) is important.

### Type deductions

https://www.learncpp.com/cpp-tutorial/type-deduction-with-pointers-references-and-const/

### Void Pointers

The **void pointer**, also known as the generic pointer, is a special type of pointer that can be pointed at objects of any data type! A void pointer is declared like a normal pointer, using the void keyword as the pointer’s type:

```cpp
void* ptr; // ptr is a void pointer
```

A void pointer can point to objects of any data type:

```cpp
int nValue;
float fValue;

struct Something
{
    int n;
    float f;
};

Something sValue;

void* ptr;
ptr = &nValue; // valid
ptr = &fValue; // valid
ptr = &sValue; // valid
```

However, because the void pointer does not know what type of object it is pointing to, dereferencing a void pointer is illegal. Instead, the void pointer must first be cast to another pointer type before the dereference can be performed.

```cpp
int value{ 5 };
void* voidPtr{ &value };

// std::cout << *voidPtr << '\n'; // illegal: dereference of void pointer

int* intPtr{ static_cast<int*>(voidPtr) }; // however, if we cast our void pointer to an int pointer...

std::cout << *intPtr << '\n'; // then we can dereference the result
```

It is not possible to do pointer arithmetic on a void pointer. This is because pointer arithmetic requires the pointer to know what size object it is pointing to, so it can increment or decrement the pointer appropriately.

In general, it is a good idea to avoid using void pointers unless absolutely necessary, as they effectively allow you to avoid type checking. This allows you to inadvertently do things that make no sense, and the compiler won’t complain about it. 

### Pointer to Pointer

A pointer to a pointer is exactly what you’d expect: a pointer that holds the address of another pointer.

```cpp
int** ptrptr; // pointer to a pointer to an int, two asterisks
```

A pointer to a pointer works just like a normal pointer — you can perform indirection through it to retrieve the value pointed to. And because that value is itself a pointer, you can perform indirection through it again to get to the underlying value. These indirections can be done consecutively:

```cpp
int value { 5 };

int* ptr { &value };
std::cout << *ptr << '\n'; // Indirection through pointer to int to get int value

int** ptrptr { &ptr };
std::cout << **ptrptr << '\n'; // first indirection to get pointer to int, second indirection to get int value
```

Note that you can not set a pointer to a pointer directly to a value:

```cpp
int value { 5 };
int** ptrptr { &&value }; // not valid
```

This is because the address of operator (operator&) requires an lvalue, but &value is an rvalue.

However, a pointer to a pointer can be set to null. 

Pointers to pointers have a few uses. The most common use is to dynamically allocate an array of pointers:

## Constant variables

In programming, a **constant** is a value that may not be changed. 

```cpp
const double gravity { 9.8 };  // preferred use of const before type
int const sidesInSquare { 4 }; // "east const" style, okay but not preferred
```

**Best practice:** Place `const` before the type (because it is more idiomatic to do so).

**Best practice:** Don’t use `const` when passing by value. (such as function arguments)

**Best practice**: Prefer constant variables over object-like macros with substitution text.

Constant expressions:

A **constant expression** is an expression that can be evaluated by the compiler at compile-time. 

**Key insight:** Evaluating constant expressions at compile-time makes our compilation take longer (because the compiler has to do more work), but such expressions only need to be evaluated once (rather than every time the program is run). The resulting executables are faster and use less memory.

A const variable is a compile-time constant if its initializer is a constant expression. (eg, const int etc...)

Compile-time constants enable the compiler to perform optimizations that aren’t available with non-compile-time constants. For example, for example whenever the constant `gravity` is used, the compiler can simply substitute the identifier `gravity` with the literal double `9.8`, which avoids having to fetch the value from somewhere in memory.

**Runtime constants** are constants whose initialization values aren’t known until runtime.

When using `const`, our variables could end up as either a compile-time const or a runtime const, depending on whether the initializer is a compile-time expression or not.

A **constexpr** (which is short for “constant expression”) variable can only be a compile-time constant. If the initialization value of a constexpr variable is not a constant expression, the compiler will error.

**Best practice:**

1. Any variable that should not be modifiable after initialization and whose initializer is known at compile-time should be declared as `constexpr`.
2. Any variable that should not be modifiable after initialization and whose initializer is not known at compile-time should be declared as `const`.

Keep in mind the compiler can optimize in more ways!

## Literals

**Literals** are unnamed values inserted directly into the code. For example:

```cpp
return 5;                   // 5 is an integer literal
bool myNameIsAlex { true }; // true is a boolean literal
std::cout << 3.4;           // 3.4 is a double literal
```

Literals are sometimes called **literal constants** because their values cannot be reassigned.

Just like objects have a type, all literals have a type. The type of a literal is deduced from the literal’s value. For example, a literal that is a whole number (e.g. `5`) is deduced to be of type `int`.

**Best practice**: Prefer literal suffix L (upper case) over l (lower case).

![image-20221004113428423](C:\Users\Johan\AppData\Roaming\Typora\typora-user-images\image-20221004113428423.png)

## Magic numbers:

A **magic number** is a literal (usually a number) that either has an unclear meaning or may need to be changed later.

In complex programs, it can be very difficult to infer what a literal represents, unless there’s a comment to explain it.

**Best practice:** Avoid magic numbers in your code (use constexpr variables instead).

## Type Conversions

The value of an object is stored as a sequence of bits, and the data type of the object tells the compiler how to interpret those bits into meaningful values. Different data types may represent the “same” number differently.

For example, the integer value 3 might be stored as binary `0000 0000 0000 0000 0000 0000 0000 0011`, whereas floating point value 3.0 might be stored as binary `0100 0000 0100 0000 0000 0000 0000 0000`.

In most cases, C++ will allow us convert values of one fundamental type to another fundamental type. The process of converting a value from one type to another type is called **type conversion**.

When the compiler does type conversion on our behalf without us explicitly asking, we call this **implicit type conversion**. Eg. double 5.0 become int 5.

**Key insight:** Type conversion produces a new value of the target type from a value of a different type.

**Key insight:** Some type conversions are always safe to make (such as `int` to `double`), whereas others may result in the value being changed during conversion (such as `double` to `int`). Unsafe implicit conversions will typically either generate a compiler warning, or (in the case of brace initialization) an error.

### Explicit type conversion

```cpp
static_cast<new_type>(expression)
```

**Key insight:** Whenever you see C++ syntax (excluding the preprocessor) that makes use of angled brackets (<>), the thing between the angled brackets will most likely be a type. This is typically how C++ deals with code that need a parameterized type.

**Warning:** The static_cast operator will produce undefined behavior if the value being converted doesn’t fit in range of the new type.

Example:

```cpp
char ch{ 97 }; // 97 is ASCII code for 'a'
std::cout << ch << " has value " << static_cast<int>(ch) << '\n'; // print value of variable ch as an int
```

#### Type casting:

C++ supports 5 different types of casts: `C-style casts`, `static casts`, `const casts`, `dynamic casts`, and `reinterpret casts`. The latter four are sometimes referred to as **named casts**. 

**Warning**: Avoid const casts and reinterpret casts unless you have a very good reason to use them.

**Best practice**: Favor static_cast when you need to convert a value from one type to another type. (The above)

### Implicit type conversion

Performed automatically by the compiler when one data type is required, but a different data type is supplied.

When a type conversion is invoked (whether implicitly or explicitly), the compiler will determine whether it can convert the value from the current type to the desired type. If a valid conversion can be found, then the compiler will produce a new value of the desired type.

If the compiler can’t find an acceptable conversion, then the compilation will fail with a compile error.

**As an aside:** How do you have a type conversion with zero conversions? As an example, on architectures where `int` and `long` both have the same size and range, the same sequence of bits is used to represent values of both types. Therefore, no actual conversion is needed to convert a value between those types -- the value can simply be copied.

The C++ language standard defines how different fundamental types (and in some cases, compound types) can be converted to other types. These conversion rules are called the **standard conversions**.

### Numeric Promotions

**A reminder:** The number of bits a data type uses is called its width. A wider data type is one that uses more bits, and a narrower data type is one that uses less bits.

Because C++ is designed to be portable and performant across a wide range of architectures, the language designers did not want to assume a given CPU would be able to efficiently manipulate values that were narrower than the natural data size for that CPU. 

A **numeric promotion** is the type conversion of a narrower numeric type (such as a `char`) to a wider numeric type (typically `int` or `double`) that can be processed efficiently and is less likely to have a result that overflows. 

All numeric promotions are **value-preserving**, which means that all values in the original type are representable without loss of data or precision in the new type. Because such promotions are safe, the compiler will freely use numeric promotion as needed, and will not issue a warning when doing so.

Create a function that only has int as input argument. Numeric promotion can allow us to called with types tha can be **numerically promoted** to match the function parameters.

#### Floating Point Promotion

Using the **floating point promotion** rules, a value of type `float` can be converted to a value of type `double`. 

#### Integral promotion

More complicated than previous category.

- signed char or signed short can be converted to int.
- unsigned char, char8_t, and unsigned short can be converted to int if int can hold the entire range of the type, or unsigned int otherwise.
- If char is signed by default, it follows the signed char conversion rules above. If it is unsigned by default, it follows the unsigned char conversion rules above.
- bool can be converted to int, with false becoming 0 and true becoming 1.

### Numeric Conversions

C++ supports another category of numeric type conversions, called **numeric conversions**, that cover additional type conversions not covered by the numeric promotion rules. 

#### Narrowing conversions

Unlike a numeric promotion (which is always safe), a numeric conversion may (or may not) result in the loss of data or precision.

**Warning**: Compilers will often *not* warn when converting a signed int to an unsigned int, or vice-versa, even though these are narrowing conversions. Be extra careful of inadvertent conversions between these types (particularly when passing an argument to a function taking a parameter of the opposite sign).

**Best practice**: Avoid narrowing conversions whenever possible. If you do need to perform one, use `static_cast` to make it an explicit conversion.

### Arithmetic Conversions

When we mix different types in an operation. 

In C++, certain operators require that their operands be of the same type. If one of these operators is invoked with operands of different types, one or both of the operands will be implicitly converted to matching types using a set of rules called the **usual arithmetic conversions**.

#### The operators that require operands of the same type

The following operators require their operands to be of the same type:

- The binary arithmetic operators: +, -, *, /, %
- The binary relational operators: <, >, <=, >=, ==, !=
- The binary bitwise arithmetic operators: &, ^, |
- The conditional operator ?: (excluding the condition, which is expected to be of type `bool`)

#### The usual arithmetic conversion rules

The usual arithmetic conversion rules are pretty simple. The compiler has a prioritized list of types that looks something like this:

- long double (highest)
- double
- float
- unsigned long long
- long long
- unsigned long
- long
- unsigned int
- int (lowest)

Also:

- If the type of at least one of the operands is on the priority list, the operand with lower priority is converted to the type of the operand with higher priority.
- Otherwise (the type of neither operand is on the list), both operands are numerically promoted

### Functions

To see what type of a resulting expression use typeid.name(),example:

```cpp
#include <iostream>
#include <typeinfo> // for typeid()

int main()
{
    int i{ 2 };
    double d{ 3.5 };
    std::cout << typeid(i + d).name() << ' ' << i + d << '\n'; // show us the type of i + d

    return 0;
}
```

## Typedefs and type aliases

In C++, **using** is a keyword that creates an alias for an existing data type. To create such a type alias, we use the `using` keyword, followed by a name for the type alias, followed by an equals sign and an existing data type. For example:

```cpp
using Distance = double; // define Distance as an alias for type double
```

```cpp
Distance milesToDestination{ 3.4 }; // defines a variable of type double
```

#### **Naming type aliases**

Historically, there hasn’t been a lot of consistency in how type aliases have been named. There are three common naming conventions (and you will run across all of them):

- Type aliases that end in a “_t” suffix (the “_t” is short for “type”). This convention is often used by the standard library for globally scoped type names (like `size_t` and `nullptr_t`).
- Type aliases that end in a “_type” suffix. This convention is used by some standard library types (like `std::string`) to name nested type aliases (e.g. `std::string::size_type`).

- Type aliases that use no suffix.

In modern C++, the convention is to name type aliases (or any other type) that you define yourself starting with a capital letter, and using no suffix. The capital letter helps differentiate the names of types from the names of variables and functions (which start with a lower case letter), and prevents naming collisions between them.

**Best practice**: Name your type aliases starting with a capital letter and do not use a suffix (unless you have a specific reason to do otherwise).

An alias does not actually define a new, distinct type (one that is considered separate from other types) -- it just introduces a new identifier for an existing type. A type alias is completely interchangeable with the aliased type.

Because scope is a property of an identifier, type alias identifiers follow the same scoping rules as variable identifiers: a type alias defined inside a block has block scope and is usable only within that block, whereas a type alias defined in the global namespace has file scope and is usable to the end of the file.

Uses:

### **Using type aliases for platform independent coding**

One of the primary uses for type aliases is to hide platform specific details. On some platforms, an `int` is 2 bytes, and on others, it is 4 bytes. Thus, using `int` to store more than 2 bytes of information can be potentially dangerous when writing platform independent code.

```cpp
#ifdef INT_2_BYTES
using int8_t = char;
using int16_t = int;
using int32_t = long;
#else
using int8_t = char;
using int16_t = short;
using int32_t = int;
#endif
```

### **Using type aliases to make complex types easier to read**

Although we have only dealt with simple data types so far, in advanced C++, types can be complicated and lengthy to manually enter on your keyboard.

### **Using type aliases for legibility**

Type aliases can also help with code documentation and comprehension.

With variables, we have the variable’s identifier to help document the purpose of the variable. But consider the case of a function’s return value. Data types such as `char`, `int`, `long`, `double`, and `bool` are describe what *type* a function returns, but more often we want to know what *purpose* a return value serves.

**Best practice**: Use type aliases judiciously, when they provide a clear benefit to code readability or code maintenance.

## Type deductions

**Type deduction** (also sometimes called **type inference**) is a feature that allows the compiler to deduce the type of an object from the object’s initializer. To use type deduction, the `auto` keyword is used in place of the variable’s type. 

```cpp
int main()
{
    auto d{ 5.0 }; // 5.0 is a double literal, so d will be type double
    auto i{ 1 + 2 }; // 1 + 2 evaluates to an int, so i will be type int
    auto x { i }; // i is an int, so x will be type int too

    return 0;
}
```

Type deduction will not work for objects that do not have initializers or empty initializers.

In most cases, type deduction will drop the `const` qualifier from deduced types. For example:

```cpp
int main()
{
    const int x { 5 }; // x has type const int
    auto y { x };      // y will be type int (const is dropped)
}
```

### Pros and cons:

Type deduction is not only convenient, but also has a number of other benefits.

First, if two or more variables are defined on sequential lines, the names of the variables will be lined up, helping to increase readability:

```cpp
// harder to read
int a { 5 };
double b { 6.7 };

// easier to read
auto c { 5 };
auto d { 6.7 };
```

Second, type deduction only works on variables that have initializers, so if you are in the habit of using type deduction, it can help avoid unintentionally uninitialized variables:

```cpp
int x; // oops, we forgot to initialize x, but the compiler may not complain
auto y; // the compiler will error out because it can't deduce a type for y
```

Third, you are guaranteed that there will be no unintended performance-impacting conversions:

```cpp
double x { 5 }; // bad: implicitly converts 5 from an int to a double
auto y { 5 }; // good: y is an int (hopefully that's what you wanted) and no conversion takes place
```

Type deduction also has a few downsides.

First, type deduction obscures an object’s type information in the code. Although a good IDE should be able to show you the deduced type (e.g. when hovering a variable), it’s still a bit easier to make type-based mistakes when using type deduction.

```cpp
auto y { 5 }; // oops, we wanted a double here but we accidentally provided an int literal
```

Second, if the type of an initializer changes, the type of a variable using type deduction will also change, perhaps unexpectedly. Consider:

```cpp
auto sum { add(5, 6) + gravity };
```

If the return type of `add` changes from int to double, or `gravity` changes from int to double, `sum` will also change types from int to double.

**Best practice**: Use type deduction for your variables, unless you need to commit to a specific type.

### Functions:

**Best practice**: Favor explicit return types over function return type deduction for normal functions.

**Type deduction can’t be used for function parameter types**

## Extra:

### Outputting values in decimal, octal, or hexadecimal:

By default, C++ outputs values in decimal. However, you can change the output format via use of the `std::dec`, `std::oct`, and `std::hex` I/O manipulators.